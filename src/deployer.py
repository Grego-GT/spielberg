"""Actor deployment module for creating and building Actors on Apify platform.

This module uses the Apify API to create Actors, add source code, and trigger builds.
"""

import os
import asyncio
from typing import Dict, Any, Optional
from apify_client import ApifyClientAsync
from apify import Actor


class ActorDeployer:
    """Deploys generated Actors to the Apify platform."""
    
    def __init__(self, apify_token: Optional[str] = None):
        """Initialize the deployer with Apify client.
        
        Args:
            apify_token: Apify API token (uses APIFY_TOKEN env var if not provided)
        """
        token = apify_token or os.environ.get('APIFY_TOKEN')
        if not token:
            raise ValueError("APIFY_TOKEN is required for deployment")
        
        self.client = ApifyClientAsync(token=token)
    
    async def deploy(self, actor_files: Dict[str, str], actor_name: str) -> Dict[str, Any]:
        """Deploy Actor to Apify platform.
        
        Args:
            actor_files: Dictionary mapping file paths to contents
            actor_name: Name for the Actor
            
        Returns:
            Dictionary with actor_id, build_id, and deployment info
            
        Raises:
            Exception: If deployment fails
        """
        Actor.log.info(f"Starting deployment for Actor: {actor_name}")
        
        try:
            # Step 1: Create the Actor (with version 0.1 already included)
            actor = await self._create_actor(actor_files, actor_name)
            actor_id = actor['id']
            Actor.log.info(f"Created Actor with ID: {actor_id}")
            
            # Step 2: Trigger build (version was already created in step 1)
            build = await self._trigger_build(actor_id)
            build_id = build['id']
            Actor.log.info(f"Triggered build with ID: {build_id}")
            
            return {
                'actor_id': actor_id,
                'build_id': build_id,
                'version': '0.1',
                'console_url': f"https://console.apify.com/actors/{actor_id}",
                'status': 'building'
            }
            
        except Exception as e:
            Actor.log.error(f"Deployment failed: {str(e)}")
            raise Exception(f"Failed to deploy Actor: {str(e)}")
    
    async def _create_actor(self, actor_files: Dict[str, str], actor_name: str) -> Dict[str, Any]:
        """Create a new Actor on Apify platform.
        
        Args:
            actor_files: Actor source files
            actor_name: Actor name
            
        Returns:
            Created Actor object
        """
        import json
        
        # Parse actor.json to get metadata
        actor_json = json.loads(actor_files.get('.actor/actor.json', '{}'))
        
        # Prepare Actor creation payload with correct parameter names (snake_case for Python client)
        actor_data = {
            'name': actor_name,
            'title': actor_json.get('title', actor_name),
            'description': actor_json.get('description', 'Actor generated by Spielberg'),
            'is_public': False,
            'seo_title': actor_json.get('title', actor_name),
            'seo_description': actor_json.get('description', 'Actor generated by Spielberg'),
            'versions': [{
                'versionNumber': '0.1',
                'sourceType': 'SOURCE_FILES',
                'buildTag': 'latest',
                'sourceFiles': self._prepare_source_files(actor_files)
            }]
        }
        
        Actor.log.info("Creating Actor via Apify API...")
        actor = await self.client.actors().create(**actor_data)
        
        return actor
    
    async def _create_version(self, actor_id: str, actor_files: Dict[str, str]) -> Dict[str, Any]:
        """Create a new version for the Actor.
        
        Args:
            actor_id: Actor ID
            actor_files: Source files
            
        Returns:
            Created version object
        """
        # Note: Version is already created during Actor creation
        # This method can be used for updates if needed
        versions = await self.client.actor(actor_id).versions().list()
        if versions and versions.get('items'):
            return versions['items'][0]
        
        # If no version exists, create one
        version_data = {
            'versionNumber': '0.1',
            'sourceType': 'SOURCE_FILES',
            'buildTag': 'latest',
            'sourceFiles': self._prepare_source_files(actor_files)
        }
        
        version = await self.client.actor(actor_id).versions().create(**version_data)
        return version
    
    async def _trigger_build(self, actor_id: str) -> Dict[str, Any]:
        """Trigger a build for the Actor.
        
        Args:
            actor_id: Actor ID
            
        Returns:
            Build object
        """
        Actor.log.info(f"Triggering build for Actor {actor_id}...")
        
        # Use the actor().build() method directly
        build = await self.client.actor(actor_id).build(
            version_number='0.1',
            tag='latest',
            wait_for_finish=0  # Don't wait, we'll poll separately
        )
        
        return build
    
    def _prepare_source_files(self, actor_files: Dict[str, str]) -> list:
        """Prepare source files for API submission.
        
        Args:
            actor_files: Dictionary of file paths to contents
            
        Returns:
            List of file objects for API
        """
        source_files = []
        
        for file_path, content in actor_files.items():
            # Normalize path (remove leading ./)
            normalized_path = file_path.lstrip('./')
            
            source_files.append({
                'name': normalized_path,
                'format': 'TEXT',
                'content': content
            })
        
        return source_files
    
    async def get_build_status(self, actor_id: str, build_id: str) -> Dict[str, Any]:
        """Get the status of a build.
        
        Args:
            actor_id: Actor ID
            build_id: Build ID
            
        Returns:
            Build status information
        """
        # Use builds() collection to access a specific build
        build = await self.client.build(build_id).get()
        
        return {
            'build_id': build_id,
            'status': build.get('status'),
            'started_at': build.get('startedAt'),
            'finished_at': build.get('finishedAt'),
            'usage': build.get('usage', {})
        }
    
    async def get_build_log(self, actor_id: str, build_id: str) -> str:
        """Get the build log.
        
        Args:
            actor_id: Actor ID
            build_id: Build ID
            
        Returns:
            Build log as string
        """
        try:
            log = await self.client.log(build_id).get()
            return log if isinstance(log, str) else str(log)
        except Exception as e:
            Actor.log.warning(f"Could not fetch build log: {str(e)}")
            return f"Log unavailable: {str(e)}"
    
    async def wait_for_build(self, actor_id: str, build_id: str, timeout: int = 300) -> Dict[str, Any]:
        """Wait for build to complete.
        
        Args:
            actor_id: Actor ID
            build_id: Build ID
            timeout: Maximum seconds to wait
            
        Returns:
            Final build status
        """
        Actor.log.info(f"Waiting for build {build_id} to complete (timeout: {timeout}s)...")
        
        start_time = asyncio.get_event_loop().time()
        
        while True:
            # Check timeout
            elapsed = asyncio.get_event_loop().time() - start_time
            if elapsed > timeout:
                raise TimeoutError(f"Build did not complete within {timeout} seconds")
            
            # Get build status
            status = await self.get_build_status(actor_id, build_id)
            build_status = status.get('status')
            
            Actor.log.info(f"Build status: {build_status}")
            
            # Check if build is done
            if build_status in ['SUCCEEDED', 'FAILED', 'ABORTED', 'TIMED-OUT']:
                return status
            
            # Wait before next check
            await asyncio.sleep(5)
    
    async def update_actor_version(self, actor_id: str, version_number: str, 
                                   actor_files: Dict[str, str]) -> Dict[str, Any]:
        """Update an existing Actor version with new source files.
        
        Args:
            actor_id: Actor ID
            version_number: Version to update
            actor_files: New source files
            
        Returns:
            Updated version object
        """
        Actor.log.info(f"Updating Actor {actor_id} version {version_number}...")
        
        version = await self.client.actor(actor_id).version(version_number).update(
            source_type='SOURCE_FILES',
            source_files=self._prepare_source_files(actor_files)
        )
        
        return version


async def deploy_actor(actor_files: Dict[str, str], actor_name: str) -> Dict[str, Any]:
    """Main function to deploy an Actor.
    
    Args:
        actor_files: Dictionary mapping file paths to contents
        actor_name: Name for the Actor
        
    Returns:
        Deployment information including actor_id and build_id
        
    Raises:
        Exception: If deployment fails
    """
    deployer = ActorDeployer()
    return await deployer.deploy(actor_files, actor_name)

